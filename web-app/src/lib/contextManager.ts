/**
 * 智能上下文管理系统
 * 管理对话上下文、规则、资源引用等
 */

import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// ============ 类型定义 ============

export interface ContextSummary {
  id: string
  threadId: string
  content: string
  keyPoints: string[]
  createdAt: Date
  updatedAt: Date
  autoGenerated: boolean
}

export interface Rule {
  id: string
  name: string
  description: string
  type: 'global' | 'thread'  // 简化为全局和对话级别
  threadId?: string  // 如果是对话级别，关联的对话ID
  content: string
  priority: number
  active: boolean
  editable?: boolean  // 是否可编辑
  conditions?: {
    keywords?: string[]
    fileTypes?: string[]
    context?: string
  }
  createdAt: Date
  updatedAt: Date
}

export interface Resource {
  id: string
  type: 'file' | 'mcp' | 'url' | 'code' | 'knowledge'
  scope: 'global' | 'thread'  // 资源范围
  threadId?: string  // 如果是对话级别，关联的对话ID
  name: string
  path?: string
  content?: string
  metadata?: Record<string, any>
  pinned: boolean
  editable?: boolean  // 是否可编辑
  lastAccessed: Date
}

export interface Knowledge {
  id: string
  title: string
  content: string
  type: 'documentation' | 'specification' | 'guideline' | 'snippet'
  tags: string[]
  source?: string
  createdAt: Date
  updatedAt: Date
}

// 每个对话的 UI 状态
export interface ThreadUIState {
  isPanelOpen: boolean
  activeTab: 'summary' | 'rules' | 'resources' | 'knowledge'
  currentSummary: ContextSummary | null
}

export interface ContextState {
  // 上下文总结
  summaries: Map<string, ContextSummary>
  
  // 规则系统
  rules: Rule[]
  activeRules: string[]
  
  // 资源管理
  resources: Resource[]
  pinnedResources: string[]
  
  // 知识库
  knowledge: Knowledge[]
  
  // UI 状态（每个对话独立）
  threadUIStates: Map<string, ThreadUIState>
  panelWidth: number
  
  // 智能上下文开关状态（每个对话独立）
  contextEnabled: Map<string, boolean>
}

export interface ContextActions {
  // 上下文总结操作
  generateSummary: (threadId: string, messages: any[]) => Promise<ContextSummary>
  updateSummary: (id: string, content: string) => void
  getSummary: (threadId: string) => ContextSummary | undefined
  getSummaryForContext: (threadId: string, maxTokens?: number) => string | null
  
  // 规则操作
  addRule: (rule: Omit<Rule, 'id' | 'createdAt' | 'updatedAt'>) => void
  updateRule: (id: string, updates: Partial<Rule>) => void
  deleteRule: (id: string) => void
  toggleRule: (id: string) => void
  getActiveRules: (threadId?: string) => Rule[]  // 支持获取特定对话的规则
  getGlobalRules: () => Rule[]
  getThreadRules: (threadId: string) => Rule[]
  
  // 资源操作
  addResource: (resource: Omit<Resource, 'id' | 'lastAccessed'>) => void
  updateResource: (id: string, updates: Partial<Resource>) => void
  removeResource: (id: string) => void
  pinResource: (id: string) => void
  unpinResource: (id: string) => void
  getResource: (id: string) => Resource | undefined
  getGlobalResources: () => Resource[]
  getThreadResources: (threadId: string) => Resource[]
  getActiveResources: (threadId?: string) => Resource[]  // 支持获取特定对话的资源
  
  // 知识库操作
  addKnowledge: (knowledge: Omit<Knowledge, 'id' | 'createdAt' | 'updatedAt'>) => void
  updateKnowledge: (id: string, updates: Partial<Knowledge>) => void
  deleteKnowledge: (id: string) => void
  searchKnowledge: (query: string) => Knowledge[]
  
  // UI 操作（基于 threadId）
  togglePanel: (threadId: string) => void
  setPanelWidth: (width: number) => void
  setActiveTab: (threadId: string, tab: ThreadUIState['activeTab']) => void
  getPanelState: (threadId: string) => ThreadUIState
  getCurrentSummary: (threadId: string) => ContextSummary | null
  
  // 智能上下文开关
  toggleContextEnabled: (threadId: string) => void
  isContextEnabled: (threadId: string) => boolean
  
  // 清理操作（删除对话时调用）
  cleanupThread: (threadId: string) => void
  
  // 导入/导出
  exportContext: () => string
  importContext: (data: string) => void
}

// ============ Store 实现 ============

export const useContextManager = create<ContextState & ContextActions>()(
  persist(
    (set, get) => ({
      // 初始状态
      summaries: new Map(),
      rules: [],
      activeRules: [],
      resources: [],
      pinnedResources: [],
      knowledge: [],
      threadUIStates: new Map(),
      panelWidth: 320,
      contextEnabled: new Map(),  // 默认关闭
      
      // 上下文总结操作
      generateSummary: async (threadId, _messages) => {
        // 简化实现：直接创建空白总结供用户编辑
        const summary: ContextSummary = {
          id: `summary-${Date.now()}`,
          threadId,
          content: '请编辑对话总结...',
          keyPoints: [],
          createdAt: new Date(),
          updatedAt: new Date(),
          autoGenerated: false,
        }
        
        set((state) => {
          const newSummaries = new Map(state.summaries)
          newSummaries.set(threadId, summary)
          
          // 更新对应线程的 UI 状态
          const newThreadUIStates = new Map(state.threadUIStates)
          const currentUIState = newThreadUIStates.get(threadId) || {
            isPanelOpen: false,  // 默认关闭
            activeTab: 'summary' as const,
            currentSummary: null
          }
          newThreadUIStates.set(threadId, {
            ...currentUIState,
            currentSummary: summary
          })
          
          return { 
            summaries: newSummaries,
            threadUIStates: newThreadUIStates
          }
        })
        
        return summary
      },
      
      updateSummary: (id, content) => {
        set((state) => {
          const newSummaries = new Map(state.summaries)
          const summary = Array.from(newSummaries.values()).find(s => s.id === id)
          if (summary) {
            summary.content = content
            summary.updatedAt = new Date()
            summary.autoGenerated = false
          }
          return { summaries: newSummaries }
        })
      },
      
      getSummary: (threadId) => {
        return get().summaries.get(threadId)
      },
      
      // 获取总结用于发送上下文（带 token 限制）
      getSummaryForContext: (threadId, maxTokens = 1000) => {
        const summary = get().summaries.get(threadId)
        if (!summary || !summary.content) return null
        
        // 简单的 token 估算：平均每个字符约 0.5 tokens（中文约 2 tokens/字）
        // 对于混合内容，我们使用保守估计
        const estimateTokens = (text: string) => {
          const chineseChars = text.match(/[\u4e00-\u9fa5]/g)?.length || 0
          const otherChars = text.length - chineseChars
          return Math.ceil(chineseChars * 2 + otherChars * 0.5)
        }
        
        let content = summary.content
        let tokens = estimateTokens(content)
        
        // 如果超过限制，截断内容
        if (tokens > maxTokens) {
          // 按比例截断
          const ratio = maxTokens / tokens
          const targetLength = Math.floor(content.length * ratio * 0.9) // 留 10% 余量
          content = content.slice(0, targetLength)
          
          // 确保不在句子中间截断
          const lastPeriod = content.lastIndexOf('。')
          const lastNewline = content.lastIndexOf('\n')
          const cutPoint = Math.max(lastPeriod, lastNewline)
          
          if (cutPoint > targetLength * 0.8) {
            content = content.slice(0, cutPoint + 1)
          }
          
          content += '...[内容已截断]'
        }
        
        // 添加上下文说明
        return `【对话总结】\n${content}\n【总结结束】`
      },
      
      // 规则操作
      addRule: (ruleData) => {
        const rule: Rule = {
          ...ruleData,
          id: `rule-${Date.now()}`,
          createdAt: new Date(),
          updatedAt: new Date(),
        }
        
        set((state) => ({
          rules: [...state.rules, rule],
          activeRules: rule.active 
            ? [...state.activeRules, rule.id]
            : state.activeRules
        }))
      },
      
      updateRule: (id, updates) => {
        set((state) => ({
          rules: state.rules.map(rule =>
            rule.id === id
              ? { ...rule, ...updates, updatedAt: new Date() }
              : rule
          )
        }))
      },
      
      deleteRule: (id) => {
        set((state) => ({
          rules: state.rules.filter(rule => rule.id !== id),
          activeRules: state.activeRules.filter(ruleId => ruleId !== id)
        }))
      },
      
      toggleRule: (id) => {
        set((state) => {
          const rule = state.rules.find(r => r.id === id)
          if (!rule) return state
          
          const newRules = state.rules.map(r =>
            r.id === id ? { ...r, active: !r.active } : r
          )
          
          const newActiveRules = rule.active
            ? state.activeRules.filter(ruleId => ruleId !== id)
            : [...state.activeRules, id]
          
          return {
            rules: newRules,
            activeRules: newActiveRules
          }
        })
      },
      
      getActiveRules: (threadId) => {
        const state = get()
        const allRules = state.rules.filter(rule => rule.active)
        
        if (!threadId) {
          // 如果没有指定 threadId，返回所有激活的规则
          return allRules
        }
        
        // 获取对话级别的规则
        const threadRules = allRules.filter(rule => 
          rule.type === 'thread' && rule.threadId === threadId
        )
        
        // 获取全局规则（如果没有对话级别的规则覆盖）
        const globalRules = allRules.filter(rule => 
          rule.type === 'global'
        )
        
        // 合并规则，对话级别优先
        const ruleMap = new Map<string, Rule>()
        
        // 先添加全局规则
        globalRules.forEach(rule => {
          ruleMap.set(rule.name, rule)
        })
        
        // 对话规则覆盖同名的全局规则
        threadRules.forEach(rule => {
          ruleMap.set(rule.name, rule)
        })
        
        return Array.from(ruleMap.values()).sort((a, b) => a.priority - b.priority)
      },
      
      getGlobalRules: () => {
        return get().rules.filter(rule => rule.type === 'global')
      },
      
      getThreadRules: (threadId) => {
        return get().rules.filter(rule => 
          rule.type === 'thread' && rule.threadId === threadId
        )
      },
      
      // 资源操作
      addResource: (resourceData) => {
        const resource: Resource = {
          ...resourceData,
          id: `resource-${Date.now()}`,
          lastAccessed: new Date(),
        }
        
        set((state) => ({
          resources: [...state.resources, resource],
          pinnedResources: resource.pinned 
            ? [...state.pinnedResources, resource.id]
            : state.pinnedResources
        }))
      },
      
      updateResource: (id, updates) => {
        set((state) => ({
          resources: state.resources.map(resource =>
            resource.id === id
              ? { ...resource, ...updates, lastAccessed: new Date() }
              : resource
          )
        }))
      },
      
      removeResource: (id) => {
        set((state) => ({
          resources: state.resources.filter(r => r.id !== id),
          pinnedResources: state.pinnedResources.filter(rid => rid !== id)
        }))
      },
      
      pinResource: (id) => {
        set((state) => ({
          resources: state.resources.map(r =>
            r.id === id ? { ...r, pinned: true } : r
          ),
          pinnedResources: [...new Set([...state.pinnedResources, id])]
        }))
      },
      
      unpinResource: (id) => {
        set((state) => ({
          resources: state.resources.map(r =>
            r.id === id ? { ...r, pinned: false } : r
          ),
          pinnedResources: state.pinnedResources.filter(rid => rid !== id)
        }))
      },
      
      getResource: (id) => {
        return get().resources.find(r => r.id === id)
      },
      
      getGlobalResources: () => {
        return get().resources.filter(resource => resource.scope === 'global')
      },
      
      getThreadResources: (threadId) => {
        return get().resources.filter(resource => 
          resource.scope === 'thread' && resource.threadId === threadId
        )
      },
      
      getActiveResources: (threadId) => {
        const state = get()
        
        if (!threadId) {
          // 返回所有资源
          return state.resources
        }
        
        // 获取对话级别的资源
        const threadResources = state.resources.filter(resource => 
          resource.scope === 'thread' && resource.threadId === threadId
        )
        
        // 获取全局资源
        const globalResources = state.resources.filter(resource => 
          resource.scope === 'global'
        )
        
        // 合并资源，对话级别优先
        const resourceMap = new Map<string, Resource>()
        
        // 先添加全局资源
        globalResources.forEach(resource => {
          resourceMap.set(resource.name, resource)
        })
        
        // 对话资源覆盖同名的全局资源
        threadResources.forEach(resource => {
          resourceMap.set(resource.name, resource)
        })
        
        return Array.from(resourceMap.values())
      },
      
      // 知识库操作
      addKnowledge: (knowledgeData) => {
        const knowledge: Knowledge = {
          ...knowledgeData,
          id: `knowledge-${Date.now()}`,
          createdAt: new Date(),
          updatedAt: new Date(),
        }
        
        set((state) => ({
          knowledge: [...state.knowledge, knowledge]
        }))
      },
      
      updateKnowledge: (id, updates) => {
        set((state) => ({
          knowledge: state.knowledge.map(k =>
            k.id === id
              ? { ...k, ...updates, updatedAt: new Date() }
              : k
          )
        }))
      },
      
      deleteKnowledge: (id) => {
        set((state) => ({
          knowledge: state.knowledge.filter(k => k.id !== id)
        }))
      },
      
      searchKnowledge: (query) => {
        const lowerQuery = query.toLowerCase()
        return get().knowledge.filter(k =>
          k.title.toLowerCase().includes(lowerQuery) ||
          k.content.toLowerCase().includes(lowerQuery) ||
          k.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
        )
      },
      
      // UI 操作
      togglePanel: (threadId) => {
        set((state) => {
          const newThreadUIStates = new Map(state.threadUIStates)
          const currentUIState = newThreadUIStates.get(threadId) || {
            isPanelOpen: true,
            activeTab: 'summary' as const,
            currentSummary: state.summaries.get(threadId) || null
          }
          newThreadUIStates.set(threadId, {
            ...currentUIState,
            isPanelOpen: !currentUIState.isPanelOpen
          })
          return { threadUIStates: newThreadUIStates }
        })
      },
      
      setPanelWidth: (width) => {
        set({ panelWidth: width })
      },
      
      setActiveTab: (threadId, tab) => {
        set((state) => {
          const newThreadUIStates = new Map(state.threadUIStates)
          const currentUIState = newThreadUIStates.get(threadId) || {
            isPanelOpen: true,
            activeTab: 'summary' as const,
            currentSummary: state.summaries.get(threadId) || null
          }
          newThreadUIStates.set(threadId, {
            ...currentUIState,
            activeTab: tab
          })
          return { threadUIStates: newThreadUIStates }
        })
      },
      
      getPanelState: (threadId) => {
        const state = get()
        return state.threadUIStates.get(threadId) || {
          isPanelOpen: false,  // 默认关闭
          activeTab: 'summary' as const,
          currentSummary: state.summaries.get(threadId) || null
        }
      },
      
      getCurrentSummary: (threadId) => {
        const state = get()
        const uiState = state.threadUIStates.get(threadId)
        return uiState?.currentSummary || state.summaries.get(threadId) || null
      },
      
      // 智能上下文开关
      toggleContextEnabled: (threadId) => {
        set((state) => {
          const newContextEnabled = new Map(state.contextEnabled)
          const currentState = newContextEnabled.get(threadId) || false
          newContextEnabled.set(threadId, !currentState)
          return { contextEnabled: newContextEnabled }
        })
      },
      
      isContextEnabled: (threadId) => {
        return get().contextEnabled.get(threadId) || false
      },
      
      // 清理对话相关数据
      cleanupThread: (threadId) => {
        set((state) => {
          // 清理总结
          const newSummaries = new Map(state.summaries)
          newSummaries.delete(threadId)
          
          // 清理对话级别的规则
          const newRules = state.rules.filter(rule => 
            !(rule.type === 'thread' && rule.threadId === threadId)
          )
          
          // 清理对话级别的资源
          const newResources = state.resources.filter(resource => 
            !(resource.scope === 'thread' && resource.threadId === threadId)
          )
          
          // 清理开关状态
          const newContextEnabled = new Map(state.contextEnabled)
          newContextEnabled.delete(threadId)
          
          // 清理 UI 状态
          const newThreadUIStates = new Map(state.threadUIStates)
          newThreadUIStates.delete(threadId)
          
          return {
            summaries: newSummaries,
            rules: newRules,
            resources: newResources,
            contextEnabled: newContextEnabled,
            threadUIStates: newThreadUIStates
          }
        })
      },
      
      // 导入/导出
      exportContext: () => {
        const state = get()
        const exportData = {
          summaries: Array.from(state.summaries.entries()),
          rules: state.rules,
          resources: state.resources,
          knowledge: state.knowledge,
          timestamp: new Date().toISOString()
        }
        return JSON.stringify(exportData, null, 2)
      },
      
      importContext: (data) => {
        try {
          const importData = JSON.parse(data)
          set({
            summaries: new Map(importData.summaries || []),
            rules: importData.rules || [],
            resources: importData.resources || [],
            knowledge: importData.knowledge || [],
          })
        } catch (error) {
          console.error('Failed to import context:', error)
        }
      },
    }),
    {
      name: 'miaoda-context-manager',
      partialize: (state) => ({
        rules: state.rules,
        knowledge: state.knowledge,
        panelWidth: state.panelWidth,
      })
    }
  )
)

// ============ 工具函数 ============

/**
 * 从消息中提取关键信息
 */
export function extractKeyPoints(messages: any[]): string[] {
  // TODO: 实现关键信息提取逻辑
  const keyPoints: string[] = []
  
  // 示例：提取代码块、文件名、重要概念等
  messages.forEach(msg => {
    // 提取代码语言
    const codeMatches = msg.content?.match(/```(\w+)/g)
    if (codeMatches) {
      codeMatches.forEach((match: string) => {
        const lang = match.replace('```', '')
        if (!keyPoints.includes(`代码: ${lang}`)) {
          keyPoints.push(`代码: ${lang}`)
        }
      })
    }
    
    // 提取文件路径
    const pathMatches = msg.content?.match(/\/[\w\-./]+\.\w+/g)
    if (pathMatches) {
      pathMatches.forEach((path: string) => {
        if (!keyPoints.includes(`文件: ${path}`)) {
          keyPoints.push(`文件: ${path}`)
        }
      })
    }
  })
  
  return keyPoints
}

/**
 * 生成默认规则
 */
export function getDefaultRules(): Omit<Rule, 'id' | 'createdAt' | 'updatedAt'>[] {
  return [
    {
      name: '代码质量',
      description: '确保生成的代码符合最佳实践',
      type: 'global',
      content: '始终遵循项目的代码规范，包括命名约定、注释风格和错误处理',
      priority: 1,
      active: true,
    },
    {
      name: '中文优先',
      description: '界面和文档使用中文',
      type: 'global',
      content: '用户界面和文档优先使用简体中文，技术术语可保留英文',
      priority: 2,
      active: true,
    },
    {
      name: '安全第一',
      description: '避免生成不安全的代码',
      type: 'global',
      content: '不生成可能造成安全风险的代码，包括硬编码密钥、SQL注入等',
      priority: 0,
      active: true,
    },
  ]
}