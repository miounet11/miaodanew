/**
 * 智能上下文管理系统
 * 管理对话上下文、规则、资源引用等
 */

import { create } from 'zustand'
import { persist } from 'zustand/middleware'

// ============ 类型定义 ============

export interface ContextSummary {
  id: string
  threadId: string
  content: string
  keyPoints: string[]
  createdAt: Date
  updatedAt: Date
  autoGenerated: boolean
}

export interface Rule {
  id: string
  name: string
  description: string
  type: 'global' | 'project' | 'thread'
  content: string
  priority: number
  active: boolean
  conditions?: {
    keywords?: string[]
    fileTypes?: string[]
    context?: string
  }
  createdAt: Date
  updatedAt: Date
}

export interface Resource {
  id: string
  type: 'file' | 'mcp' | 'url' | 'code' | 'knowledge'
  name: string
  path?: string
  content?: string
  metadata?: Record<string, any>
  pinned: boolean
  lastAccessed: Date
}

export interface Knowledge {
  id: string
  title: string
  content: string
  type: 'documentation' | 'specification' | 'guideline' | 'snippet'
  tags: string[]
  source?: string
  createdAt: Date
  updatedAt: Date
}

export interface ContextState {
  // 上下文总结
  summaries: Map<string, ContextSummary>
  currentSummary: ContextSummary | null
  
  // 规则系统
  rules: Rule[]
  activeRules: string[]
  
  // 资源管理
  resources: Resource[]
  pinnedResources: string[]
  
  // 知识库
  knowledge: Knowledge[]
  
  // UI 状态
  isPanelOpen: boolean
  panelWidth: number
  activeTab: 'summary' | 'rules' | 'resources' | 'knowledge'
}

export interface ContextActions {
  // 上下文总结操作
  generateSummary: (threadId: string, messages: any[]) => Promise<ContextSummary>
  updateSummary: (id: string, content: string) => void
  getSummary: (threadId: string) => ContextSummary | undefined
  getSummaryForContext: (threadId: string, maxTokens?: number) => string | null
  
  // 规则操作
  addRule: (rule: Omit<Rule, 'id' | 'createdAt' | 'updatedAt'>) => void
  updateRule: (id: string, updates: Partial<Rule>) => void
  deleteRule: (id: string) => void
  toggleRule: (id: string) => void
  getActiveRules: () => Rule[]
  
  // 资源操作
  addResource: (resource: Omit<Resource, 'id' | 'lastAccessed'>) => void
  removeResource: (id: string) => void
  pinResource: (id: string) => void
  unpinResource: (id: string) => void
  getResource: (id: string) => Resource | undefined
  
  // 知识库操作
  addKnowledge: (knowledge: Omit<Knowledge, 'id' | 'createdAt' | 'updatedAt'>) => void
  updateKnowledge: (id: string, updates: Partial<Knowledge>) => void
  deleteKnowledge: (id: string) => void
  searchKnowledge: (query: string) => Knowledge[]
  
  // UI 操作
  togglePanel: () => void
  setPanelWidth: (width: number) => void
  setActiveTab: (tab: ContextState['activeTab']) => void
  
  // 导入/导出
  exportContext: () => string
  importContext: (data: string) => void
}

// ============ Store 实现 ============

export const useContextManager = create<ContextState & ContextActions>()(
  persist(
    (set, get) => ({
      // 初始状态
      summaries: new Map(),
      currentSummary: null,
      rules: [],
      activeRules: [],
      resources: [],
      pinnedResources: [],
      knowledge: [],
      isPanelOpen: true,
      panelWidth: 320,
      activeTab: 'summary',
      
      // 上下文总结操作
      generateSummary: async (threadId, messages) => {
        // 导入总结生成器和获取服务
        const { generateAISummary, generateLocalSummary } = await import('./contextSummarizer')
        
        // 先创建占位符
        const placeholderSummary: ContextSummary = {
          id: `summary-${Date.now()}`,
          threadId,
          content: '正在使用 AI 生成对话总结...',
          keyPoints: [],
          createdAt: new Date(),
          updatedAt: new Date(),
          autoGenerated: true,
        }
        
        set((state) => {
          const newSummaries = new Map(state.summaries)
          newSummaries.set(threadId, placeholderSummary)
          return { 
            summaries: newSummaries,
            currentSummary: placeholderSummary
          }
        })
        
        try {
          // 尝试使用 grok-3 模型生成总结
          const { getServiceHub } = await import('@/hooks/useServiceHub')
          const { streamCompletion } = await import('./completion')
          
          // 配置 grok-3 模型参数
          const modelService = {
            complete: async (params: any) => {
              const provider = {
                provider: 'miaoda',
                base_url: 'https://grok.x.ai/v1',
                api_key: '', // 免费服务不需要 API key
              }
              
              const model = {
                model: 'grok-3',
                name: 'Grok 3',
                provider: 'miaoda',
              }
              
              let responseContent = ''
              
              // 使用流式 API 获取响应
              for await (const chunk of streamCompletion({
                provider,
                model,
                messages: params.messages,
                temperature: params.temperature || 0.3,
                max_tokens: params.max_tokens || 500,
              })) {
                if (chunk.choices[0]?.delta?.content) {
                  responseContent += chunk.choices[0].delta.content
                }
              }
              
              return { content: responseContent }
            }
          }
          
          // 使用 AI 生成总结
          const result = await generateAISummary(messages, modelService, 'zh')
          
          // 更新总结内容
          const summary: ContextSummary = {
            ...placeholderSummary,
            content: result.summary,
            keyPoints: result.keyPoints,
            updatedAt: new Date(),
          }
          
          set((state) => {
            const newSummaries = new Map(state.summaries)
            newSummaries.set(threadId, summary)
            return { 
              summaries: newSummaries,
              currentSummary: summary
            }
          })
          
          return summary
        } catch (error) {
          console.error('AI summary generation failed, falling back to local:', error)
          
          // 如果 AI 生成失败，降级到本地生成
          const result = generateLocalSummary(messages)
          
          const summary: ContextSummary = {
            ...placeholderSummary,
            content: result.summary,
            keyPoints: result.keyPoints,
            updatedAt: new Date(),
          }
          
          set((state) => {
            const newSummaries = new Map(state.summaries)
            newSummaries.set(threadId, summary)
            return { 
              summaries: newSummaries,
              currentSummary: summary
            }
          })
          
          return summary
        }
      },
      
      updateSummary: (id, content) => {
        set((state) => {
          const newSummaries = new Map(state.summaries)
          const summary = Array.from(newSummaries.values()).find(s => s.id === id)
          if (summary) {
            summary.content = content
            summary.updatedAt = new Date()
            summary.autoGenerated = false
          }
          return { summaries: newSummaries }
        })
      },
      
      getSummary: (threadId) => {
        return get().summaries.get(threadId)
      },
      
      // 获取总结用于发送上下文（带 token 限制）
      getSummaryForContext: (threadId, maxTokens = 1000) => {
        const summary = get().summaries.get(threadId)
        if (!summary || !summary.content) return null
        
        // 简单的 token 估算：平均每个字符约 0.5 tokens（中文约 2 tokens/字）
        // 对于混合内容，我们使用保守估计
        const estimateTokens = (text: string) => {
          const chineseChars = text.match(/[\u4e00-\u9fa5]/g)?.length || 0
          const otherChars = text.length - chineseChars
          return Math.ceil(chineseChars * 2 + otherChars * 0.5)
        }
        
        let content = summary.content
        let tokens = estimateTokens(content)
        
        // 如果超过限制，截断内容
        if (tokens > maxTokens) {
          // 按比例截断
          const ratio = maxTokens / tokens
          const targetLength = Math.floor(content.length * ratio * 0.9) // 留 10% 余量
          content = content.slice(0, targetLength)
          
          // 确保不在句子中间截断
          const lastPeriod = content.lastIndexOf('。')
          const lastNewline = content.lastIndexOf('\n')
          const cutPoint = Math.max(lastPeriod, lastNewline)
          
          if (cutPoint > targetLength * 0.8) {
            content = content.slice(0, cutPoint + 1)
          }
          
          content += '...[内容已截断]'
        }
        
        // 添加上下文说明
        return `【对话总结】\n${content}\n【总结结束】`
      },
      
      // 规则操作
      addRule: (ruleData) => {
        const rule: Rule = {
          ...ruleData,
          id: `rule-${Date.now()}`,
          createdAt: new Date(),
          updatedAt: new Date(),
        }
        
        set((state) => ({
          rules: [...state.rules, rule],
          activeRules: rule.active 
            ? [...state.activeRules, rule.id]
            : state.activeRules
        }))
      },
      
      updateRule: (id, updates) => {
        set((state) => ({
          rules: state.rules.map(rule =>
            rule.id === id
              ? { ...rule, ...updates, updatedAt: new Date() }
              : rule
          )
        }))
      },
      
      deleteRule: (id) => {
        set((state) => ({
          rules: state.rules.filter(rule => rule.id !== id),
          activeRules: state.activeRules.filter(ruleId => ruleId !== id)
        }))
      },
      
      toggleRule: (id) => {
        set((state) => {
          const rule = state.rules.find(r => r.id === id)
          if (!rule) return state
          
          const newRules = state.rules.map(r =>
            r.id === id ? { ...r, active: !r.active } : r
          )
          
          const newActiveRules = rule.active
            ? state.activeRules.filter(ruleId => ruleId !== id)
            : [...state.activeRules, id]
          
          return {
            rules: newRules,
            activeRules: newActiveRules
          }
        })
      },
      
      getActiveRules: () => {
        return get().rules.filter(rule => rule.active)
      },
      
      // 资源操作
      addResource: (resourceData) => {
        const resource: Resource = {
          ...resourceData,
          id: `resource-${Date.now()}`,
          lastAccessed: new Date(),
        }
        
        set((state) => ({
          resources: [...state.resources, resource],
          pinnedResources: resource.pinned 
            ? [...state.pinnedResources, resource.id]
            : state.pinnedResources
        }))
      },
      
      removeResource: (id) => {
        set((state) => ({
          resources: state.resources.filter(r => r.id !== id),
          pinnedResources: state.pinnedResources.filter(rid => rid !== id)
        }))
      },
      
      pinResource: (id) => {
        set((state) => ({
          resources: state.resources.map(r =>
            r.id === id ? { ...r, pinned: true } : r
          ),
          pinnedResources: [...new Set([...state.pinnedResources, id])]
        }))
      },
      
      unpinResource: (id) => {
        set((state) => ({
          resources: state.resources.map(r =>
            r.id === id ? { ...r, pinned: false } : r
          ),
          pinnedResources: state.pinnedResources.filter(rid => rid !== id)
        }))
      },
      
      getResource: (id) => {
        return get().resources.find(r => r.id === id)
      },
      
      // 知识库操作
      addKnowledge: (knowledgeData) => {
        const knowledge: Knowledge = {
          ...knowledgeData,
          id: `knowledge-${Date.now()}`,
          createdAt: new Date(),
          updatedAt: new Date(),
        }
        
        set((state) => ({
          knowledge: [...state.knowledge, knowledge]
        }))
      },
      
      updateKnowledge: (id, updates) => {
        set((state) => ({
          knowledge: state.knowledge.map(k =>
            k.id === id
              ? { ...k, ...updates, updatedAt: new Date() }
              : k
          )
        }))
      },
      
      deleteKnowledge: (id) => {
        set((state) => ({
          knowledge: state.knowledge.filter(k => k.id !== id)
        }))
      },
      
      searchKnowledge: (query) => {
        const lowerQuery = query.toLowerCase()
        return get().knowledge.filter(k =>
          k.title.toLowerCase().includes(lowerQuery) ||
          k.content.toLowerCase().includes(lowerQuery) ||
          k.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
        )
      },
      
      // UI 操作
      togglePanel: () => {
        set((state) => ({ isPanelOpen: !state.isPanelOpen }))
      },
      
      setPanelWidth: (width) => {
        set({ panelWidth: width })
      },
      
      setActiveTab: (tab) => {
        set({ activeTab: tab })
      },
      
      // 导入/导出
      exportContext: () => {
        const state = get()
        const exportData = {
          summaries: Array.from(state.summaries.entries()),
          rules: state.rules,
          resources: state.resources,
          knowledge: state.knowledge,
          timestamp: new Date().toISOString()
        }
        return JSON.stringify(exportData, null, 2)
      },
      
      importContext: (data) => {
        try {
          const importData = JSON.parse(data)
          set({
            summaries: new Map(importData.summaries || []),
            rules: importData.rules || [],
            resources: importData.resources || [],
            knowledge: importData.knowledge || [],
          })
        } catch (error) {
          console.error('Failed to import context:', error)
        }
      },
    }),
    {
      name: 'miaoda-context-manager',
      partialize: (state) => ({
        rules: state.rules,
        knowledge: state.knowledge,
        panelWidth: state.panelWidth,
        activeTab: state.activeTab,
      })
    }
  )
)

// ============ 工具函数 ============

/**
 * 从消息中提取关键信息
 */
export function extractKeyPoints(messages: any[]): string[] {
  // TODO: 实现关键信息提取逻辑
  const keyPoints: string[] = []
  
  // 示例：提取代码块、文件名、重要概念等
  messages.forEach(msg => {
    // 提取代码语言
    const codeMatches = msg.content?.match(/```(\w+)/g)
    if (codeMatches) {
      codeMatches.forEach((match: string) => {
        const lang = match.replace('```', '')
        if (!keyPoints.includes(`代码: ${lang}`)) {
          keyPoints.push(`代码: ${lang}`)
        }
      })
    }
    
    // 提取文件路径
    const pathMatches = msg.content?.match(/\/[\w\-./]+\.\w+/g)
    if (pathMatches) {
      pathMatches.forEach((path: string) => {
        if (!keyPoints.includes(`文件: ${path}`)) {
          keyPoints.push(`文件: ${path}`)
        }
      })
    }
  })
  
  return keyPoints
}

/**
 * 生成默认规则
 */
export function getDefaultRules(): Omit<Rule, 'id' | 'createdAt' | 'updatedAt'>[] {
  return [
    {
      name: '代码质量',
      description: '确保生成的代码符合最佳实践',
      type: 'global',
      content: '始终遵循项目的代码规范，包括命名约定、注释风格和错误处理',
      priority: 1,
      active: true,
    },
    {
      name: '中文优先',
      description: '界面和文档使用中文',
      type: 'global',
      content: '用户界面和文档优先使用简体中文，技术术语可保留英文',
      priority: 2,
      active: true,
    },
    {
      name: '安全第一',
      description: '避免生成不安全的代码',
      type: 'global',
      content: '不生成可能造成安全风险的代码，包括硬编码密钥、SQL注入等',
      priority: 0,
      active: true,
    },
  ]
}